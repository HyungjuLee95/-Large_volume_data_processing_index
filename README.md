# -Large_volume_data_processing_index
대용량데이터 처리의 꽃, INDEX를 알아보고, 성능 비교를 해보자

## 생각
![image](https://github.com/HyungjuLee95/-Large_volume_data_processing_index/assets/111270174/e29f7b24-b50c-46fa-ae04-0e413025d437)

CPU가 데이터를 가져오거나 저장하기 위해서는 I/O(입출력) 버스를 통하게 되며, 아래 장치들로 데이터를 보내게된다.
여기서 저장하기 위한 용도로 메모리와 디스크를 사용한다. 생각을 해본다면 결국에는 데이터는 디스크에 저장이 되어야한다.
<strong>디스크는 메모리에 비해 속도가 느리기 때문에, 결국! 데이터베이스 성능의 핵심은 디스크 I/O를 최소화 하는 것이다.</strong>

### 어떻게?
메모리에 올라온 데이터로 최대한 요청을 처리하는 것 => 메모리 캐시 히트율을 높이는 것
읽기 쓰기 중, 쓰기도 메모리에 먼저 쓰는 방법 -> 전원이 꺼져 메모리에 저장한 데이터가 유실된다면? 이것을 고려하여 WAL(Write Ahead Log)를 사용.

![image](https://github.com/HyungjuLee95/-Large_volume_data_processing_index/assets/111270174/effadfd0-59cc-41e8-bb46-babed49c9899)
랜덤I/O 정말 무작위로 데이터를 가져오는 것.
순차 I/O 연속된 블락의 데이터를 읽어오는 것.

대부분의 트랜잭션은 무작위하게 Write가 발생한다.
예를 들어 A테이블의 10번 ID를 업데이트를 하거나, 100 번 ID를 가진 걸 업데이트를 할 수 있는데, 이를 보면 대부분 무작위하게 Write할 수 있음.
앞에서 언급한 wal은 하나의 파일에 끝부분부터 순차적으로 write만 쌓아두는 것.

즉, 이렇게 하게된다면 랜던 I/O보다는 순자 I/O가 진행이 된다.

그래서! 데이터베이스는 업데이트는 디스크에 가서 저장하는 것은 비효율적이기 때문에 메모리에 쌓아두고 한번에 넣으면 되잖아! 라는 생각을 할 수 있다.
그럼 전원이 꺼지게된다면? 데이터가 유실이 된다면 파일에 순차적으로 쌓아두었던 로그를 순차적으로 실행시키면 다시 복구할 수 있다.

